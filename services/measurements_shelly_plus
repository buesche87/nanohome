#!/bin/bash
#/////////////////////////////////////////////////////////////////////////////////////
# Nanohome Shelly Plus measurement watcher
#
# Subscribe to the status topic of all devices
# Check the connected status of each component not filtered in config
# For each connected component parse the status json and write values to influxdb
#/////////////////////////////////////////////////////////////////////////////////////

# TODO: Test
# MQTT_SERVER="nanohome.buesche.one"

MQTT_CONNECTION_STRING=(
	-h "${MQTT_SERVER}"
	-u "${MQTT_USER}"
	-P "${MQTT_PASSWORD}"
)


# Convert string-boolean to 1 or 0
convert_value() {
	[[ "$1" == "true" ]] || [[ "$1" == "on" ]] && echo 1 || echo 0
}

# Main Service
mosquitto_sub "${MQTT_CONNECTION_STRING[@]}" \
	--nodelay --quiet -F "%j" \
	-t "${MQTT_TOPIC_STATUS}" | \
	while read -r COMPONENTSTATUS; do

	# Extract information from mosquitto subscription
	STATUSTOPIC=$( jq -r '.topic' <<< "${COMPONENTSTATUS}" )
	STATUSMESSAGE=$( jq -r '.payload' <<< "${COMPONENTSTATUS}" )

	DEVICEID=$( cut -d '/' -f 1 <<< "${STATUSTOPIC}" )
	COMPONENT=$( cut -d '/' -f 3 <<< "${STATUSTOPIC}" )

	jq -r 'to_entries[] | "\(.key), \(.value)"' <<< "${STATUSMESSAGE}" | \
	while IFS=, read -r COMPONENT VALUE; do

		# Don't monitor components excluded in config
		if [[ " ${NANOHOME_NOT_MONITORED_COMPONENTS//,/ } " == *" ${COMPONENT} "* ]]; then
			continue
		fi

		# Debug
		echo "Measurements - Monitored: ${DEVICEID}/${COMPONENT}"
		jq <<< ${STATUSMESSAGE}

		CONNECTED=$(
			mosquitto_sub "${MQTT_CONNECTION_STRING[@]}" \
			--retained-only --nodelay --quiet -C 1 -W 1 \
			-t "${DEVICEID}/status/${COMPONENT}/connected"
		)

		CONNECTEDVALUE=$(
			convert_value "${CONNECTED}"
		)

		# Get description
		DESCRIPTION=$(
			mosquitto_sub "${MQTT_CONNECTION_STRING[@]}" \
			--retained-only --nodelay --quiet -C 1 -W 1 \
			-t "${DEVICEID}/status/${COMPONENT}/description"
		)

		DESCRIPTION_ESCAPED="${DESCRIPTION// /\\ }"

		# Only monitor connected devices and those with a description
		if [[ $CONNECTEDVALUE -eq 0 ]] || [[ -z "${DESCRIPTION}" ]]; then
			continue
		fi		

		# Parse message payload
		POWER=$( jq -r '.apower' <<< "${STATUSMESSAGE}" )
		ENERGY=$(jq -r '.aenergy.total' <<< "${STATUSMESSAGE}" )
		VOLTAGE=$( jq -r '.voltage' <<< "${STATUSMESSAGE}" )
		CURRENT=$( jq -r '.current' <<< "${STATUSMESSAGE}" )
		DEVICETEMP=$( jq -r '.temperature.tC' <<< "${STATUSMESSAGE}" )
		CURRENTPOSITION=$( jq -r '.current_pos' <<< "${STATUSMESSAGE}" )
		ROOM_TEMP=$( jq -r '.tC' <<< "${STATUSMESSAGE}" )
		ROOM_HUM=$( jq -r '.rh' <<< "${STATUSMESSAGE}" )
		BATTERY=$( jq -r '.battery.percent' <<< "${STATUSMESSAGE}" )

		# Prepare payload
		PAYLOAD='{
			"measurement": "'"${DESCRIPTION_ESCAPED}"'",
			"tags": {
				"Device": "'"${DEVICEID}"'",
				"Component": "'"${COMPONENT}"'"
			},
			"fields": {}
		}'

		# Add fields with value to payload
		[[ "${POWER}" != "null" ]] && PAYLOAD=$(
			jq --arg value "${POWER}" '.fields.Power = $value' <<< "${PAYLOAD}"
		)

		[[ "${ENERGY}" != "null" ]] && PAYLOAD=$(
			jq --arg value "${ENERGY}" '.fields.Energy = $value' <<< "${PAYLOAD}"
		)

		[[ "${VOLTAGE}" != "null" ]] && PAYLOAD=$(
			jq --arg value "${VOLTAGE}" '.fields.Voltage = $value' <<< "${PAYLOAD}"
		)

		[[ "${CURRENT}" != "null" ]] && PAYLOAD=$(
			jq --arg value "${CURRENT}" '.fields.Current = $value' <<< "${PAYLOAD}"
		)

		[[ "${DEVICETEMP}" != "null" ]] && PAYLOAD=$(
			jq --arg value "${DEVICETEMP}" '.fields.Devicetemp = $value' <<< "${PAYLOAD}"
		)

		[[ "${ROOM_TEMP}" != "null" ]] && PAYLOAD=$(
			jq --arg value "${ROOM_TEMP}" '.fields.Temperature = $value' <<< "${PAYLOAD}"
		)

		[[ "${ROOM_HUM}" != "null" ]] && PAYLOAD=$(
			jq --arg value "${ROOM_HUM}" '.fields.Humidity = $value' <<< "${PAYLOAD}"
		)

		[[ "${BATTERY}" != "null" ]] && PAYLOAD=$(
			jq --arg value "${BATTERY}" '.fields.Battery = $value' <<< "${PAYLOAD}"
		)

		# Debug
		echo "Measurements - Payload: ${DEVICEID}/${COMPONENT}"
		jq <<< "${PAYLOAD}"

		PAYLOAD_LINE=$(
			jq -r '[
			.measurement as $measurement |
			.tags as $tags |
			.fields as $fields |
			($tags | to_entries | map("\(.key)=\(.value|tostring)") | join(",")) as $tags_str |
			($fields | to_entries | map("\(.key)=\(.value|tostring)") | join(",")) as $fields_str |
			"\($measurement),\($tags_str) \($fields_str)"
			] | .[]' <<< "${PAYLOAD}"
		)

		# Insert values into influxdb
		influx write -b "${INFLUX_BUCKET_MEASUREMENTS}" <<< "${PAYLOAD_LINE}"
	done
done
