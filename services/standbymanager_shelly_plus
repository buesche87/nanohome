#!/bin/bash
#/////////////////////////////////////////////////////////////////////////////////////
# nanohome - standbymanager service
#
# Turn off output if power goes below threshold
# - Subscribe to the components status topic
# - Extract current output power from every message
# - Check if power is below threshold 
# - Turn off output if so
#/////////////////////////////////////////////////////////////////////////////////////

# MQTT connection string with credentials
MQTT_CONNECTION_STRING=(
	-h "${MQTT_SERVER}"
	-u "${MQTT_USER}"
	-P "${MQTT_PASSWORD}"
)

# MQTT retained message subscription options
MQTT_RETAINED_OPTIONS=(
	--retained-only
	--nodelay
	--quiet
	-C 1
	-W 1
)

# Temporary storage for active services
STATE_FILE="/tmp/standbymanager_shelly_plus.state"
touch "$STATE_FILE"

#===============================================================
# Functions
#===============================================================

# Start background service
start_standbyservice() {
    local msg="$1"
    local id=$( echo -n "$msg" | md5sum | cut -d ' ' -f1 )



    # Check if service is already running
    if grep -q "$id" "$STATE_FILE"; then
        echo "Service for [$msg] already running."
		[[ $LOG_DEBUG ]] && echo -e "${LOG_INFO} Standbymanager: ${DESCRIPTION}: ${LOGMESSAGE}"
    else
        echo "Starting service for [$msg]..."
        nohup ./your_service.sh "$msg" > "/tmp/service_$id.log" 2>&1 & echo "$id $!" >> "$STATE_FILE"
    fi
}

# Stop background service
stop_standbyservice() {
    local id="$1"

    if grep -q "$id" "$STATE_FILE"; then
        local pid=$(grep "$id" "$STATE_FILE" | awk '{print $2}')
        echo "Stopping service for [$id] (PID: $pid)..."
        kill "$pid"
        sed -i "/$id/d" "$STATE_FILE"
    fi
}

# Get last published standby state
get_last_state() {

	local standbyconfig=$(
		mosquitto_sub "${MQTT_CONNECTION_STRING[@]}" \
		"${MQTT_RETAINED_OPTIONS[@]}" \
		-t "${STANDBYTOPIC}"
	)

	local state=$( jq -r .state <<< "${standbyconfig}" )
	return "${state}"
}


#===============================================================
# Infinitely subscribe to "nanohome/standby/+"
#===============================================================

# Only retained messages
# Process stored and new messages
# For every json found > create a background service
# If a message gets deleted > stop the background service

mosquitto_sub "${MQTT_CONNECTION_STRING[@]}" -t "${MQTT_TOPIC_STANDBY}/+" --retained-only |
while read -r STANDBYMESSAGES; do
    if [[ -n "$message" ]]; then
        start_standbyservice "$message"
    fi
done &



mosquitto_sub "${MQTT_CONNECTION_STRING[@]}" -t "${MQTT_TOPIC_STANDBY}/+" --retained-only |
while read -r STANDBYMESSAGES; do
	id=$( echo -n "$message" | md5sum | cut -d ' ' -f1 )
    if [[ -z "$message" ]]; then
        stop_standbyservice "$message"
    fi
done &




# Extract payload and device details from json formatted message
DEVICEID=$( jq -r '.deviceId' <<< "${STANDBYCONFIG_JSON}" )
COMPONENT=$( jq -r '.component' <<< "${STANDBYCONFIG_JSON}" )
DESCRIPTION=$( jq -r '.description' <<< "${STANDBYCONFIG_JSON}" )
THRESHOLD=$( jq -r .threshold <<< "${STANDBYCONFIG_JSON}" )
STANDBYWAIT=$( jq -r .wait <<< "${STANDBYCONFIG_JSON}" )

[[ "${STANDBYWAIT}" == "null" ]] && STANDBYWAIT=1

STANDBYTOPIC="nanohome/standby/${DESCRIPTION}"
STATUSTOPIC="${DEVICEID}/status/${COMPONENT}"
CONTROLTOPIC="${DEVICEID}/command/${COMPONENT}"







#===============================================================
# Infinitely subscribe to "+/status/+"
#===============================================================

mosquitto_sub "${MQTT_CONNECTION_STRING[@]}" -t "${STATUSTOPIC}" | \
	while read -r COMPONENTSTATUS; do

	# Extract current power from json formatted message
	CURRENTPOWER=$( jq -r .apower <<< "${COMPONENTSTATUS}" )

	# Get last state
	LAST_STATE=$( get_last_state )

	# Manage standby - don't kill the device if it just started
	if awk 'BEGIN { exit !('$CURRENTPOWER' == 0) }'; then

		LOGMESSAGE="Off - nothing to do"
		NEW_STATE="off"
		
	elif awk 'BEGIN { exit !('$CURRENTPOWER' < '$THRESHOLD') }'; then
		case "${LAST_STATE}" in
			"off")
				NEW_STATE="on"
				LOGMESSAGE="Just started"
				sleep $STANDBYWAIT
				;;
			"on")
				NEW_STATE="off"
				LOGMESSAGE="Below threshold - turning off"
				mosquitto_pub "${MQTT_CONNECTION_STRING[@]}" -t "${CONTROLTOPIC}" -m "off"
				;;
			*)
				NEW_STATE="off"
				LOGMESSAGE="Something happened that shouldn't"
				;;
		esac
	elif awk 'BEGIN { exit !('$CURRENTPOWER' > '$THRESHOLD') }'; then
		case "${LAST_STATE}" in
			"off")
				NEW_STATE="on"
				LOGMESSAGE="Just started"
				sleep $STANDBYWAIT
				;;
			"on")
				NEW_STATE="on"
				LOGMESSAGE="On - nothing to do"
				;;
			*)
				NEW_STATE="off"
				LOGMESSAGE="Something happened that shouldn't"
				;;
		esac
	fi

	# Update and publish the json with new state
	if [[ "${NEW_STATE}" != "${LAST_STATE}" ]]
		
		STANDBYCONFIG_JSON_UPDATED=$(
			jq --arg state "${NEW_STATE}" '.state = "$state"' <<< "${STANDBYCONFIG_JSON}"
		)

		mosquitto_pub -r "${MQTT_CONNECTION_STRING[@]}" \
		-t "${STANDBYTOPIC}" -m "${STANDBYCONFIG_JSON_UPDATED}"
	fi

	# Log
	[[ $LOG_SERVICE ]] && echo -e "${LOG_INFO} Standbymanager: ${DESCRIPTION}: ${LOGMESSAGE}"
done
