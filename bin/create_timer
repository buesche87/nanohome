#!/bin/bash
#/////////////////////////////////////////////////////////////////////////////////////
# Nanohome Shelly timer manager
# 
# Subscribe to all timer topics and retreive the published json arrays
# Go through all entries and parse the json
# Create a crontab entry for on and off times
#/////////////////////////////////////////////////////////////////////////////////////

# Load config
source /opt/nanohome/config.cfg

# crontab entry
plus_cron="MINUTE HOUR * * PERIOD root /usr/bin/mosquitto_pub -h $mqtt_server -u $mqtt_system_user -P $mqtt_system_pass -t DEVICEID/command/COMPONENT -m MESSAGE"
legacy_cron="MINUTE HOUR * * PERIOD root /usr/bin/mosquitto_pub -h $mqtt_server -u $mqtt_system_user -P $mqtt_system_pass -t shellies/DEVICEID/COMPONENTDEV/COMPONENTIDEX/command -m MESSAGE"

# Create temporary crontab file
temp_cron=$(mktemp)
sed -n '/# Nanohome Crontabs/q;p' /etc/crontab > "$temp_cron"
echo "# Nanohome Crontabs" >> "$temp_cron"

# Subscribe to timer topic
publishedTimers=$(mosquitto_sub -h "$mqtt_server" -u "$mqtt_system_user" -P "$mqtt_system_pass" -t "$topic_timer" -W 2 --retained-only --nodelay --quiet)
configuredTimers=${publishedTimers//$'\n'/} # remove newlines
IFS=']' read -r -a timerArray <<< "$configuredTimers" # create array

# Process each timer for every device stored in the arary
for timer in "${timerArray[@]}"; do

	# count timer per device and process data
	num_objects=$(jq length <<< $timer)
	for ((i = 0; i < num_objects; i++)); do

		# Fill Variables
		deviceId=$(echo "$timer" | jq -r .[$i].deviceId )
		component=$(echo "$timer" | jq -r .[$i].component )
		description=$(echo "$timer" | jq -r .[$i].description )
		timerPeriod=$(echo "$timer" | jq -r .[$i].timerPeriodValue )
		timerPeriodText=$(echo "$timer" | jq -r .[$i].timerPeriodText )
		timerOn=$(echo "$timer" | jq -r .[$i].timerOn )
		timerOff=$(echo "$timer" | jq -r .[$i].timerOff )
		
		# Legacy
		componentDev=$(echo "$timer" | jq -r .[$i].componentDev )
		componentIndex=$(echo "$timer" | jq -r .[$i].componentIndex )

		# Debug output
		echo "---------------------------------"
		echo "deviceId: $deviceId"
		echo "component: $component"
		echo "componentDev: $componentDev"
		echo "componentIndex: $componentIndex"
		echo "description: $description"
		echo "timerPeriodText: $timerPeriodText"
		echo "timerOn: $timerOn"
		echo "timerOff: $timerOff"

		# Legacy
		if [[ "$componentDev" != "null" ]]; then
			cronEntry=${legacy_cron}
			cronEntry=$(sed "s|COMPONENTDEV|${componentDev}|g" <<< $cronEntry)
			cronEntry=$(sed "s|COMPONENTIDEX|${componentIndex}|g" <<< $cronEntry)
		else
			cronEntry=${plus_cron}
			cronEntry=$(sed "s|COMPONENT|${component}|g" <<< $cronEntry)
		fi

		# Prepare cron entry
		cronEntry=$(sed "s|PERIOD|${timerPeriod}|g" <<< $cronEntry)
		cronEntry=$(sed "s|DEVICEID|${deviceId}|g" <<< $cronEntry)

		# If timerOn set create a cron entry to switch on component
		if [[ "$timerOn" != "" ]]; then

			# Parse hour and minute from time string
			hour="${timerOn:0:2}"
			minute="${timerOn:3:5}"

			# Check component type
			case $component in
				"switch"*)
					message="on"
				;;
				"cover"*)
					message="open"
				;;
				"relay"*)
					message="on"
			esac

			# Fill cron entry with on values
			cronOnEntry=$(sed "s|MINUTE|${minute}|g" <<< $cronEntry)
			cronOnEntry=$(sed "s|HOUR|${hour}|g" <<< $cronOnEntry)
			cronOnEntry=$(sed "s|MESSAGE|${message}|g" <<< $cronOnEntry)
			
			# Append entry to temp file
			echo "$cronOnEntry" >> "$temp_cron"

			# Debug output
			# echo "$cronOnEntry"
		fi

		# If on time create on entry
		if [[ "$timerOff" != "" ]]; then

			# Parse hour and minute from time string
			hour="${timerOff:0:2}"
			minute="${timerOff:3:5}"

			# Check component type
			case $component in
				"switch"*)
					message="off"
				;;
				"cover"*)
					message="close"
				;;
				"relay"*)
					message="off"
			esac

			# Fill cron entry with off values
			cronOffEntry=$(sed "s|MINUTE|${minute}|g" <<< $cronEntry)
			cronOffEntry=$(sed "s|HOUR|${hour}|g" <<< $cronOffEntry)
			cronOffEntry=$(sed "s|MESSAGE|${message}|g" <<< $cronOffEntry)
			
			# Append entry to temp file
			echo "$cronOffEntry" >> "$temp_cron"

			# Debug output
			# echo "$cronOffEntry"
		fi
	done
done

# Save to crontab
cat $temp_cron > /etc/crontab

# Debug Output
# cat $temp_cron
