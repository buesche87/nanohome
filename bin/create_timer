#!/bin/bash
#/////////////////////////////////////////////////////////////////////////////////////
# Nanohome Shelly timer manager
# 
# Subscribe to all timer topics and retreive the published json arrays
# Go through all entries and parse the json
# Create a crontab entry for on and off times
#/////////////////////////////////////////////////////////////////////////////////////

# crontab entry
PLUSCRON="MINUTE HOUR * * PERIOD root /usr/bin/mosquitto_pub -h ${MQTT_SERVICE} -u ${MQTT_USER} -P ${MQTT_PASSWORD} -t DEVICEID/command/COMPONENT -m MESSAGE"
LEGACYCRON="MINUTE HOUR * * PERIOD root /usr/bin/mosquitto_pub -h ${MQTT_SERVICE} -u ${MQTT_USER} -P ${MQTT_PASSWORD} -t shellies/DEVICEID/COMPONENTDEV/COMPONENTIDEX/command -m MESSAGE"

# Create temporary crontab file and fill it without nanohome crons
TEMPCRON=$(mktemp)
sed '/# Nanohome Crontabs/q' /etc/crontabs/root > "${TEMPCRON}"

# Subscribe to timer topic and create array with all timers
PUBLISHEDTIMERS=$(mosquitto_sub -h "${MQTT_SERVICE}" -u "${MQTT_USER}" -P "${MQTT_PASSWORD}" -t "${TOPIC_TIMER}" -W 2 --retained-only --nodelay --quiet)
CONFIGUREDTIMERS="${PUBLISHEDTIMERS//$'\n'/}" # remove newlines
CONFIGUREDTIMERS="${CONFIGUREDTIMERS//]/];}" # replace ] with ]; to easily create an array
IFS=';' read -r -a TIMERARRAY <<< "$CONFIGUREDTIMERS"

# Process each timer for every device stored in the arary
for timer in "${TIMERARRAY[@]}"; do

	# count timer per device and process data
	num_objects=$(jq length <<< $timer)
	for ((i = 0; i < num_objects; i++)); do

		# Fill Variables
		DEVICEID=$(echo "$timer" | jq -r .[$i].deviceId )
		COMPONENT=$(echo "$timer" | jq -r .[$i].component )
		DESCRIPTION=$(echo "$timer" | jq -r .[$i].description )
		TIMERPERIOD=$(echo "$timer" | jq -r .[$i].timerPeriodValue )
		TIMERPERIODTEXT=$(echo "$timer" | jq -r .[$i].timerPeriodText )
		TIMERON=$(echo "$timer" | jq -r .[$i].timerOn )
		TIMEROFF=$(echo "$timer" | jq -r .[$i].timerOff )
		
		# Legacy
		COMPONENTDEV=$(echo "$timer" | jq -r .[$i].componentDev )
		COMPONENTINDEX=$(echo "$timer" | jq -r .[$i].componentIndex )

		# Legacy
		if [[ "${COMPONENTDEV}" != "null" ]]; then
			CRONENTRY="${LEGACYCRON}"
			CRONENTRY=$(sed "s|COMPONENTDEV|${COMPONENTDEV}|g" <<< "${CRONENTRY}")
			CRONENTRY=$(sed "s|COMPONENTIDEX|${COMPONENTIDEX}|g" <<< "${CRONENTRY}")
		else
			CRONENTRY="${PLUSCRON}"
			CRONENTRY=$(sed "s|COMPONENT|${COMPONENT}|g" <<< "${CRONENTRY}")
		fi

		# Prepare cron entry
		CRONENTRY=$(sed "s|PERIOD|${TIMERPERIOD}|g" <<< "${CRONENTRY}")
		CRONENTRY=$(sed "s|DEVICEID|${DEVICEID}|g" <<< "${CRONENTRY}")

		# If timerOn set create a cron entry to switch on component
		if [[ "${TIMERON}" != "" ]]; then
			
			CRONONENTRY="${CRONENTRY}"

			# Parse hour and minute from time string
			HOUR="${TIMERON:0:2}"
			MINUTE="${TIMERON:3:5}"

			# Check component type
			case "${COMPONENT}" in
				"switch"*)
					MESSAGE="on"
				;;
				"cover"*)
					MESSAGE="open"
				;;
				"relay"*)
					MESSAGE="on"
			esac

			# Fill cron entry with on values
			CRONONENTRY=$(sed "s|MINUTE|${MINUTE}|g" <<< "${CRONONENTRY}")
			CRONONENTRY=$(sed "s|HOUR|${HOUR}|g" <<< "${CRONONENTRY}")
			CRONONENTRY=$(sed "s|MESSAGE|${MESSAGE}|g" <<< "${CRONONENTRY}")
			
			# Append entry to temp file
			echo "${CRONONENTRY}" >> "${TEMPCRON}"
		fi

		# If on time create on entry
		if [[ "${TIMEROFF}" != "" ]]; then
		
			CRONOFFENTRY="${CRONENTRY}"

			# Parse hour and minute from time string
			HOUR="${TIMEROFF:0:2}"
			MINUTE="${TIMEROFF:3:5}"

			# Check component type
			case "${COMPONENT}" in
				"switch"*)
					MESSAGE="off"
				;;
				"cover"*)
					MESSAGE="close"
				;;
				"relay"*)
					MESSAGE="off"
			esac

			# Fill cron entry with off values
			CRONOFFENTRY=$(sed "s|MINUTE|${MINUTE}|g" <<< "${CRONOFFENTRY}")
			CRONOFFENTRY=$(sed "s|HOUR|${HOUR}|g" <<< "${CRONOFFENTRY}")
			CRONOFFENTRY=$(sed "s|MESSAGE|${MESSAGE}|g" <<< "${CRONOFFENTRY}")
			
			# Append entry to temp file
			echo "${CRONOFFENTRY}" >> "${TEMPCRON}"
		fi
	done
done

# Save to crontab
cat ${TEMPCRON} > /etc/crontab
